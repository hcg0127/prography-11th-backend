# ✅ 기능 구현 목록 & 개발 기록 (Dev Log)

과제에서 요구하는 **필수 API 16개**를 모두 구현하였으며, 각 기능에 대한 **단위 테스트(Unit Test)** 작성을 완료했습니다.
개발 과정에서 마주친 기술적 문제와 해결 방법, 그리고 설계에 대한 고민을 **Dev Note**로 남겼습니다.

---

## 1. 🔐 인증 및 회원 관리 (Auth & Member)

가장 기본이 되는 도메인으로, 데이터 무결성과 확장성을 고려하여 설계를 진행했습니다.

| # |  Method  | Path                         | 설명                 | Status |
|---|:--------:|------------------------------|--------------------|:------:|
| 1 |  `POST`  | `/api/v1/auth/login`         | 로그인 (BCrypt 암호화)   |   ✅    |
| 2 |  `GET`   | `/api/v1/members/{id}`       | 회원 정보 조회           |   ✅    |
| 3 |  `POST`  | `/api/v1/admin/members`      | 관리자 - 회원 등록        |   ✅    |
| 4 |  `GET`   | `/api/v1/admin/members`      | 관리자 - 회원 목록 (대시보드) |   ✅    |
| 5 |  `GET`   | `/api/v1/admin/members/{id}` | 관리자 - 회원 상세 조회     |   ✅    |
| 6 |  `PUT`   | `/api/v1/admin/members/{id}` | 관리자 - 회원 정보 수정     |   ✅    |
| 7 | `DELETE` | `/api/v1/admin/members/{id}` | 관리자 - 회원 탈퇴        |   ✅    |

> **💡 Dev Note #1: 데이터 정규화에 대한 고민**
> 초기 설계 시 회원의 소속 정보(`Part`, `Team`)를 단순 문자열(String)로 관리하려 했습니다.
> 하지만 **"기수별로 팀명이 바뀌거나, 오타가 발생하면 통계가 꼬이지 않을까?"** 하는 우려가 생겼습니다.
> 조금 번거롭더라도 확장성을 위해 `Parts`, `Teams` 테이블을 별도로 분리(정규화)하여 데이터 무결성을 확보했습니다.

> **💡 Dev Note #2: 단위 테스트와 Mockito**
> `MemberService` 테스트 작성 중, 실제 로직과 Mocking한 메서드가 일치하지 않아 `NullPointerException`이 발생하는 이슈가 있었습니다.
> 이를 통해 **Stubbing의 정확성**이 테스트 신뢰도에 미치는 영향을 체감했고, `ArgumentMatchers`를 활용하여 견고한 테스트 코드를 작성했습니다.

---

## 2. 👥 기수 관리 (Cohort)

기수와 회원을 연결하는 과정에서 발생할 수 있는 성능 문제를 고려했습니다.

| # | Method | Path                               | 설명       | Status |
|---|:------:|------------------------------------|----------|:------:|
| 8 | `GET`  | `/api/v1/admin/cohorts`            | 기수 목록 조회 |   ✅    |
| 9 | `GET`  | `/api/v1/admin/cohorts/{cohortId}` | 기수 상세 조회 |   ✅    |

> **💡 Dev Note #3: N+1 문제와 QueryDSL**
> 기수 상세 조회 시, 해당 기수에 속한 회원들의 정보(회원명, 파트, 팀 등)를 가져와야 했습니다.
> 단순 JPA 조회 시 **회원 수(N)만큼 추가 쿼리가 발생하는 N+1 문제**를 확인했습니다.
> 이를 해결하기 위해 QueryDSL의 `fetchJoin()`을 도입하여, 단 한 번의 쿼리로 필요한 모든 연관 데이터를 조회하도록 최적화했습니다.

---

## 3. 📅 일정 관리 (Session)

관리자와 일반 회원의 사용성을 구분하여 API를 구현했습니다.

| #  |  Method  | Path                          | 설명             | Status |
|----|:--------:|-------------------------------|----------------|:------:|
| 10 |  `GET`   | `/api/v1/sessions`            | 회원 - 일정 목록 조회  |   ✅    |
| 11 |  `GET`   | `/api/v1/admin/sessions`      | 관리자 - 일정 목록 조회 |   ✅    |
| 12 |  `POST`  | `/api/v1/admin/sessions`      | 관리자 - 일정 생성    |   ✅    |
| 13 |  `PUT`   | `/api/v1/admin/sessions/{id}` | 관리자 - 일정 수정    |   ✅    |
| 14 | `DELETE` | `/api/v1/admin/sessions/{id}` | 관리자 - 일정 삭제    |   ✅    |

---

## 4. 🎟️ QR 코드 관리 (QR Code)

출석 체크를 위한 QR 코드 생성 및 갱신 로직입니다.

| #  | Method | Path                                         | 설명       | Status |
|----|:------:|----------------------------------------------|----------|:------:|
| 15 | `POST` | `/api/v1/admin/sessions/{sessionId}/qrcodes` | QR 코드 생성 |   ✅    |
| 16 | `PUT`  | `/api/v1/admin/qrcodes/{qrCodeId}`           | QR 코드 갱신 |   ✅    |

> **💡 Dev Note #4: QR 유효성 관리 전략**
> QR 코드는 보안을 위해 유효 시간이 짧아야 합니다. 현재는 과제 환경(H2 DB)에 맞춰 RDB에 만료 시간을 저장하고 검증하도록 구현했습니다.
> 만약 실제 대규모 트래픽 환경이라면, **Redis의 TTL(Time-To-Live) 기능**을 활용하여 DB 부하를 줄이고 자동 만료 처리를 하는 것이 더 효율적인 아키텍처가 될 것이라 생각합니다.

---

## 5. 🏗️ 아키텍처 (Architecture)

> **💡 Dev Note #5: 이상과 현실의 조율**
> 과제 요구사항에 따라 제출용 코드는 H2 Database (In-Memory)로 구성하여 별도 설치 없이 실행되도록 했습니다.
> 하지만 실제 운영 환경을 고려하지 않은 설계는 반쪽짜리라고 생각하여, `docs/SYSTEM_ARCHITECTURE.md`에는 **AWS RDS(PostgreSQL)와 Multi-AZ**를 기반으로 한 고가용성
> 아키텍처를 별도로 설계하여 첨부했습니다.